octave notes

1 ~= 2 
ans = 1

this asks is 1 equal to 2?
returns 1 which means yes

2*3 % hi this is a comment

1 && 0 % the double ampersand means logical AND - like are both the same?
ans = 0 % false

1 || 0 % OR
ans = 1 % true

xor(1.0)
ans = 1

a = 3; % semicolor suppresses output

b = 'hi';
b  % prints
>> hi

c = (3>=1);
c
c = 1 % it evaluates to true because yes, 3 is bigger than 1

a= pi
disp(sprintf('2 decimals: %0.2f', a))
3.14
disp(sprintf('2 decimals: %0.6f', a))
3.1416

format long
a
3.14159265358979
format short
3.1416


A = [1 2; 3 4; 5 6]

 1  2
 3  4
 5  6

 v = [ 1 2 3]

 1 2 3

 v = [1; 2; 3]
 1
 2
 3

 v = 1:0.1:2 % this will start a matrix at 1 and increment by 0.1 up to 2


ones(2,3) 
1 1 1
1 1 1

C= 2*ones(2,3)
2 2 2
2 2 2


rand(3,3) % drawn uniformly between 0 and 1

w= randn(1,3) % gaussian random variable and can give it the std dev
					with mean zero and std dev 1

w = (-6 + sqrt(10)* randn(1,10000)) % matrix with 10K elements and mean -6
												% variance was 10 and std dev was sqrt 10

hist(w, 50) % makes a histogram with 50 bins

I = eye(4) % identity matrix

help eye % get help for that function


A = [1 2; 3 4; 5 6]

 1  2
 3  4
 5  6

size (A) % size, have to use parenthesis
ans 3 2

size (A,2) % number of columns

v = [1 2 3 4]
length (v)
ans 4
length(A)
ans 3

pwd % show working directory
can do cd and ls

load features.dat % to open a text file that is on my desktop

who % shows what variables octave has in memory
whos % shows more detail about the variables
featuresX % show data --have to q to esc
size (featuresX)

v=priceY(1:10) % assigns the v variable to the first ten rows of priceY

save hello.mat v; % saves this variable to a file named hello.mat in pwd
save hello.mat v -ascii ; % saves as text (ASCII) otherwise saved as binary

clear % clears all the variables in your working space

A = [1 2; 3 4; 5 6]

A(3,2) % looks up by index row, column like A sub 32
ans = 6 
A(2,:) % shows the full second row
A(:,2) % shows the full second column
A([1 3], :) % shows the first and third row
A(:,2) = [10; 11;12] % assigns new numbers to column 2
A=[A, [100;101;102]]; % append another column vector to right of A matrix

A(:) % puts all elements of A into a single vector
A = [1 2; 3 4; 5 6]
B = [ 11 12; 13 14; 15 16]

C = [A B] % apprend B to the right of A
D = [B A] % append B to the left of A
C = [A; B] % append B at the bottom of A

A * C % multiply
A .* B % element wise multiplication,  can do for different size matrices

A .^2 % squares each element of A

v = [1; 2; 3]

1 ./ v % element wise reciprical of v
1 ./ A
log(v) % element wise log
exp(v) % element wise e to the ...
abs(v) % changes to absolute value (negatives become positives)
-v % just multiplies all elements by -1

v + ones(length(v),1) % increments all values by one
% this makes a matrix of v's # of rows x 1 and adds to v
A' % is A transposed
(A')' % changes it back

a = [1 15 2 0.5]
val = max(a) % return maximimum value 
[val, ind] = max(a) % returns the max value and it's index

max(A) % on a matrix, returns the biggest row

a < 3 % returns 1 if true for each value in a
ans = 1 0 1 1

find(a < 3) % returns the values that are less than 3

A = magic(3) % all rows, columns and diagonals sum up to the same % thing - convienent way to create 3x3 matrix, not useful, magic square

[r,c] = find(A >= 7) % returns row number & column number where true
a=
1
3
2
c=
1
2
3
so at 1,1 we know that value is greater than or equal to 7

sum(a) % add all elements of a
prod(a) % multiply all elements of a
floor(a) % rounds down - even 0.5 becomes 0
ceiling(a) % rounds up - 0.5 becomes 1
rand(3) % gives me a random 3 x 3 matrix
max(rand(3), rand(3)) % returns max of two random matrices

max(A,[],1) % shows me the column wise max value 
max(A,[],2) % show the max of each row
max(max(A)) % show overall max value or
A(:) % makes it a vector, so could do 
max(A(:))
A = magic(9)
sum(A,1) % per column sum
sum(A,2) % per row sum

% to find diagonal sum
eye(9) % creates 9 * 9 identity matrix (0s with 1 diagonal)
A .* eye(9) % takes element wise multiplication
sum(sum(A .*eye(9))) % multiplies all
flipud(eye(9)) % opposite of identity = permutation matrix

A = magic(3)
pinv(A) % shows inverse of A, doesn't change A
temp = pinv(a) 
temp * A % gives me the identity matrix





























